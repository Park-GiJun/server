<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>콘서트 예약 대기열 (수정된 버전)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .auto-connections {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .connection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .connection-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .connection-card.connected {
            border-color: #17a2b8;
            background: rgba(23, 162, 184, 0.2);
        }

        .connection-card.waiting {
            border-color: #ffc107;
            background: rgba(255, 193, 7, 0.2);
        }

        .connection-card.active {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.3);
            animation: pulse 2s infinite;
        }

        .connection-card.expired {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.2);
        }

        .connection-card.error {
            border-color: #dc3545;
            background: rgba(220, 53, 69, 0.3);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .position-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px auto;
            font-size: 1.2em;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .manual-connection {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }

        .message {
            font-size: 0.9em;
            margin: 10px 0;
            text-align: center;
        }

        .connection-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.9em;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            margin: 5px;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .controls {
            text-align: center;
            margin: 20px 0;
        }

        .input-group {
            margin: 10px 0;
        }

        .input-group input {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 5px;
        }

        .input-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }

        .step-info {
            background: rgba(0, 123, 255, 0.2);
            border: 1px solid rgba(0, 123, 255, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .error-info {
            background: rgba(220, 53, 69, 0.2);
            border: 1px solid rgba(220, 53, 69, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 0.9em;
        }

        .success-info {
            background: rgba(40, 167, 69, 0.2);
            border: 1px solid rgba(40, 167, 69, 0.5);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
<div class="container">
    <h1 style="text-align: center; margin-bottom: 30px;">🎵 콘서트 예약 대기열 (연결 문제 해결된 버전)</h1>

    <div class="step-info">
        <strong>🔧 수정사항:</strong><br>
        1. 토큰 생성 후 연결 지연 추가 (1초 대기)<br>
        2. 연결 실패 시 재시도 로직 추가<br>
        3. 상세한 오류 로그 및 상태 표시<br>
        4. WebSocket 연결 타임아웃 처리
    </div>

    <!-- 통계 정보 -->
    <div class="stats">
        <div class="stat-card">
            <div>총 연결</div>
            <div class="stat-number" id="totalConnections">0</div>
        </div>
        <div class="stat-card">
            <div>연결 성공</div>
            <div class="stat-number" id="connectedCount">0</div>
        </div>
        <div class="stat-card">
            <div>연결 실패</div>
            <div class="stat-number" id="failedCount">0</div>
        </div>
        <div class="stat-card">
            <div>재시도 중</div>
            <div class="stat-number" id="retryingCount">0</div>
        </div>
    </div>

    <!-- 자동 연결 (1~5번) -->
    <div class="auto-connections">
        <h3>🤖 자동 연결 테스트 (1~5번)</h3>
        <div class="controls">
            <button class="btn" onclick="createAutoConnections()">자동 연결 생성 (개선된 로직)</button>
            <button class="btn" onclick="disconnectAllAuto()">모든 자동 연결 해제</button>
            <button class="btn" onclick="retryFailedConnections()">실패한 연결 재시도</button>
        </div>
        <div class="connection-grid" id="autoConnectionGrid">
            <!-- 자동 연결들이 여기에 표시됩니다 -->
        </div>
    </div>

    <!-- 수동 연결 -->
    <div class="manual-connection">
        <h3>👤 수동 연결 테스트</h3>
        <div class="controls">
            <div class="input-group">
                <input type="text" id="manualUserId" placeholder="사용자 ID" value="manual-user">
                <input type="number" id="concertId" placeholder="콘서트 ID" value="1">
            </div>
            <button class="btn" onclick="connectManual()">수동 연결 (개선된 로직)</button>
            <button class="btn" onclick="disconnectManual()">수동 연결 해제</button>
            <button class="btn" onclick="sendStatusRequest()">상태 조회 요청</button>
        </div>

        <div id="manualStatus" style="display: none;">
            <div class="position-circle" id="manualPosition">-</div>
            <div class="message" id="manualMessage">연결 중...</div>
        </div>
    </div>

    <div class="connection-info">
        <div><strong>연결 상태:</strong> <span id="connectionStatus">연결 안됨</span></div>
        <div><strong>토큰 ID:</strong> <span id="currentTokenId">-</span></div>
        <div><strong>마지막 메시지:</strong> <span id="lastMessage">-</span></div>
        <div><strong>연결 URL:</strong> <span id="wsUrl">-</span></div>
    </div>

    <div id="messageLog" style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 10px; margin-top: 20px;">
        <h3>상세 로그</h3>
        <div id="logContent"></div>
    </div>
</div>

<script>
    let autoConnections = {}; // 자동 연결들 저장
    let manualWebsocket = null; // 수동 연결
    let manualTokenId = null; // 수동 연결 토큰
    let nextUserId = 1; // 다음 사용자 ID
    let retryAttempts = {}; // 재시도 횟수 추적

    // 페이지 로드 시 자동으로 연결 테스트
    window.addEventListener('load', function() {
        addLogMessage('페이지 로드 완료. 연결 테스트를 시작하세요.', 'info');
    });

    async function createAutoConnections() {
        addLogMessage('🚀 개선된 자동 연결 로직 시작', 'info');

        // 기존 연결 정리
        disconnectAllAuto();

        for (let i = 1; i <= 10; i++) {
            setTimeout(() => {
                createAutoConnectionWithRetry(i);
            }, i * 1000); // 1초씩 간격을 두어 순차 생성
        }
    }

    async function createAutoConnectionWithRetry(userId, attempt = 1) {
        const maxRetries = 3;
        const userIdStr = `user-${userId}`;
        const concertId = 1;

        try {
            updateConnectionCard(userId, 'connecting', `연결 시도 ${attempt}회차`, '-');
            addLogMessage(`자동 연결 ${userId}번: ${attempt}회차 시도 시작`, 'info');

            // 1단계: 토큰 생성
            addLogMessage(`자동 연결 ${userId}번: 토큰 생성 API 호출`, 'info');

            const tokenResponse = await fetch(`http://localhost:8080/queue/token/${concertId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: userIdStr
                })
            });

            if (!tokenResponse.ok) {
                throw new Error(`토큰 생성 HTTP 오류: ${tokenResponse.status} - ${tokenResponse.statusText}`);
            }

            const tokenData = await tokenResponse.json();
            let tokenId;

            // 다양한 응답 형태 처리
            if (tokenData?.data?.tokenId) {
                tokenId = tokenData.data.tokenId;
            } else if (tokenData?.data && typeof tokenData.data === 'string') {
                tokenId = tokenData.data;
            } else if (typeof tokenData === 'string') {
                tokenId = tokenData;
            } else {
                throw new Error(`토큰 응답 형식 오류: ${JSON.stringify(tokenData)}`);
            }

            if (!tokenId || typeof tokenId !== 'string') {
                throw new Error(`유효하지 않은 토큰 ID: ${tokenId} (타입: ${typeof tokenId})`);
            }

            addLogMessage(`자동 연결 ${userId}번: 토큰 생성 성공 - ${tokenId}`, 'success');
            updateConnectionCard(userId, 'token-created', '토큰 생성 완료', '-');

            // 2단계: WebSocket 연결 (1초 대기 후)
            await new Promise(resolve => setTimeout(resolve, 1000));

            addLogMessage(`자동 연결 ${userId}번: WebSocket 연결 시도`, 'info');
            updateConnectionCard(userId, 'connecting', 'WebSocket 연결 중', '-');

            const wsUrl = `ws://localhost:8080/ws/queue?tokenId=${encodeURIComponent(tokenId)}&userId=${encodeURIComponent(userIdStr)}&concertId=${concertId}`;
            const websocket = new WebSocket(wsUrl);

            // 연결 타임아웃 설정
            const connectionTimeout = setTimeout(() => {
                if (websocket.readyState === WebSocket.CONNECTING) {
                    websocket.close();
                    throw new Error('WebSocket 연결 타임아웃 (10초)');
                }
            }, 10000);

            websocket.onopen = function(event) {
                clearTimeout(connectionTimeout);
                addLogMessage(`자동 연결 ${userId}번: WebSocket 연결 성공!`, 'success');
                updateConnectionCard(userId, 'connected', '연결됨', '-');
                retryAttempts[userId] = 0; // 성공 시 재시도 카운트 리셋
                updateStats();
            };

            websocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addLogMessage(`자동 연결 ${userId}번 메시지: ${data.message} (상태: ${data.status}, 순서: ${data.position})`, 'info');

                    const statusClass = data.status?.toLowerCase() || 'unknown';
                    updateConnectionCard(userId, statusClass, data.message || '메시지 없음', data.position || '-');
                    updateStats();
                } catch (e) {
                    addLogMessage(`자동 연결 ${userId}번: 메시지 파싱 오류 - ${event.data}`, 'error');
                }
            };

            websocket.onclose = function(event) {
                clearTimeout(connectionTimeout);
                addLogMessage(`자동 연결 ${userId}번: WebSocket 종료 (코드: ${event.code}, 이유: ${event.reason})`, 'warning');
                updateConnectionCard(userId, 'expired', `연결 종료 (${event.code})`, '-');
                updateStats();
            };

            websocket.onerror = function(error) {
                clearTimeout(connectionTimeout);
                addLogMessage(`자동 연결 ${userId}번: WebSocket 오류`, 'error');
                console.error('WebSocket 오류 상세:', error);
                updateConnectionCard(userId, 'error', 'WebSocket 오류', '-');
                updateStats();
            };

            autoConnections[userId] = {
                websocket: websocket,
                tokenId: tokenId,
                userId: userIdStr,
                concertId: concertId
            };

        } catch (error) {
            addLogMessage(`자동 연결 ${userId}번 ${attempt}회차 실패: ${error.message}`, 'error');
            console.error(`자동 연결 ${userId}번 실패 상세:`, error);

            if (attempt < maxRetries) {
                retryAttempts[userId] = attempt;
                updateConnectionCard(userId, 'error', `재시도 ${attempt}/${maxRetries}`, '-');
                addLogMessage(`자동 연결 ${userId}번: 3초 후 ${attempt + 1}회차 재시도`, 'warning');

                setTimeout(() => {
                    createAutoConnectionWithRetry(userId, attempt + 1);
                }, 3000);
            } else {
                retryAttempts[userId] = maxRetries;
                updateConnectionCard(userId, 'error', '최종 실패', '-');
                addLogMessage(`자동 연결 ${userId}번: 최대 재시도 횟수 초과, 최종 실패`, 'error');
            }
            updateStats();
        }
    }

    function createConnectionCard(userId, type) {
        const grid = document.getElementById('autoConnectionGrid');
        const existingCard = document.getElementById(`connection-${userId}`);

        if (existingCard) {
            existingCard.remove();
        }

        const card = document.createElement('div');
        card.className = 'connection-card';
        card.id = `connection-${userId}`;

        card.innerHTML = `
            <div style="text-align: center;">
                <strong>${type} ${userId}번</strong>
                <div class="position-circle" id="position-${userId}">-</div>
                <div class="message" id="message-${userId}">준비 중...</div>
            </div>
        `;

        grid.appendChild(card);
    }

    function updateConnectionCard(userId, status, message, position) {
        // 카드가 없으면 생성
        if (!document.getElementById(`connection-${userId}`)) {
            createConnectionCard(userId, 'auto');
        }

        const card = document.getElementById(`connection-${userId}`);
        const positionElement = document.getElementById(`position-${userId}`);
        const messageElement = document.getElementById(`message-${userId}`);

        if (card) {
            card.className = `connection-card ${status}`;
        }

        if (positionElement) {
            if (position > 0) {
                positionElement.textContent = position;
            } else if (status === 'active') {
                positionElement.innerHTML = '✓';
            } else if (status === 'error') {
                positionElement.innerHTML = '✗';
            } else if (status === 'connecting') {
                positionElement.innerHTML = '⏳';
            } else {
                positionElement.textContent = '-';
            }
        }

        if (messageElement) {
            messageElement.textContent = message || '상태 업데이트';
        }
    }

    async function connectManual() {
        if (manualWebsocket && manualWebsocket.readyState === WebSocket.OPEN) {
            addLogMessage('이미 수동 연결이 활성화되어 있습니다.', 'warning');
            return;
        }

        let userId = document.getElementById('manualUserId').value;
        const concertId = document.getElementById('concertId').value;

        if (!userId) {
            userId = `manual-user-${nextUserId++}`;
            document.getElementById('manualUserId').value = userId;
        }

        if (!concertId) {
            addLogMessage('콘서트 ID를 입력해주세요.', 'error');
            return;
        }

        try {
            updateConnectionStatus('토큰 생성 중...', 'orange');
            addLogMessage(`수동 연결(${userId}): 개선된 연결 로직 시작`, 'info');

            // 1단계: 토큰 생성
            const tokenResponse = await fetch(`http://localhost:8080/queue/token/${concertId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: userId
                })
            });

            if (!tokenResponse.ok) {
                throw new Error(`토큰 생성 HTTP 오류: ${tokenResponse.status} - ${tokenResponse.statusText}`);
            }

            const tokenData = await tokenResponse.json();
            let tokenId;

            if (tokenData?.data?.tokenId) {
                tokenId = tokenData.data.tokenId;
            } else if (tokenData?.data && typeof tokenData.data === 'string') {
                tokenId = tokenData.data;
            } else if (typeof tokenData === 'string') {
                tokenId = tokenData;
            } else {
                throw new Error(`토큰 응답 형식 오류: ${JSON.stringify(tokenData)}`);
            }

            if (!tokenId || typeof tokenId !== 'string') {
                throw new Error(`유효하지 않은 토큰 ID: ${tokenId}`);
            }

            manualTokenId = tokenId;
            document.getElementById('currentTokenId').textContent = tokenId;
            addLogMessage(`수동 연결(${userId}): 토큰 생성 성공 - ${tokenId}`, 'success');

            updateConnectionStatus('WebSocket 연결 중... (1초 대기)', 'orange');

            // 2단계: 1초 대기 후 WebSocket 연결
            await new Promise(resolve => setTimeout(resolve, 1000));

            const wsUrl = `ws://localhost:8080/ws/queue?tokenId=${encodeURIComponent(tokenId)}&userId=${encodeURIComponent(userId)}&concertId=${concertId}`;
            document.getElementById('wsUrl').textContent = wsUrl;
            addLogMessage(`수동 연결(${userId}): WebSocket 연결 시도 - ${wsUrl}`, 'info');

            manualWebsocket = new WebSocket(wsUrl);

            // 연결 타임아웃
            const connectionTimeout = setTimeout(() => {
                if (manualWebsocket.readyState === WebSocket.CONNECTING) {
                    manualWebsocket.close();
                    throw new Error('WebSocket 연결 타임아웃 (10초)');
                }
            }, 10000);

            manualWebsocket.onopen = function(event) {
                clearTimeout(connectionTimeout);
                addLogMessage(`수동 연결(${userId}): WebSocket 연결 성공!`, 'success');
                updateConnectionStatus('연결됨', 'green');
                document.getElementById('manualStatus').style.display = 'block';

                // 연결 성공 후 상태 조회 요청
                setTimeout(() => {
                    sendStatusRequest();
                }, 500);
            };

            manualWebsocket.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addLogMessage(`수동 연결 메시지: ${data.message} (상태: ${data.status}, 순서: ${data.position})`, 'info');
                    updateManualStatus(data);
                    document.getElementById('lastMessage').textContent = data.message || '메시지 없음';
                } catch (e) {
                    addLogMessage(`수동 연결: 메시지 파싱 오류 - ${event.data}`, 'error');
                }
            };

            manualWebsocket.onclose = function(event) {
                clearTimeout(connectionTimeout);
                addLogMessage(`수동 연결(${userId}): WebSocket 종료 (코드: ${event.code}, 이유: ${event.reason})`, 'warning');
                updateConnectionStatus(`연결 종료됨 (${event.code})`, 'red');
                document.getElementById('manualStatus').style.display = 'none';
                manualWebsocket = null;
                manualTokenId = null;
            };

            manualWebsocket.onerror = function(error) {
                clearTimeout(connectionTimeout);
                addLogMessage(`수동 연결(${userId}): WebSocket 오류`, 'error');
                console.error('수동 WebSocket 오류 상세:', error);
                updateConnectionStatus('연결 오류', 'red');
                manualWebsocket = null;
                manualTokenId = null;
            };

        } catch (error) {
            addLogMessage(`수동 연결 실패: ${error.message}`, 'error');
            console.error('수동 연결 실패 상세:', error);
            updateConnectionStatus('연결 실패', 'red');
        }
    }

    function sendStatusRequest() {
        if (manualWebsocket && manualWebsocket.readyState === WebSocket.OPEN) {
            manualWebsocket.send('GET_STATUS');
            addLogMessage('상태 조회 요청 전송', 'info');
        } else {
            addLogMessage('WebSocket이 연결되지 않았습니다.', 'warning');
        }
    }

    function updateManualStatus(data) {
        const positionElement = document.getElementById('manualPosition');
        const messageElement = document.getElementById('manualMessage');

        if (positionElement) {
            if (data.position > 0) {
                positionElement.textContent = data.position;
            } else if (data.status === 'ACTIVE') {
                positionElement.innerHTML = '✓';
            } else {
                positionElement.textContent = '-';
            }
        }

        if (messageElement) {
            messageElement.textContent = data.message || '상태 업데이트';
        }
    }

    function disconnectManual() {
        if (manualWebsocket) {
            manualWebsocket.close();
            manualWebsocket = null;
            manualTokenId = null;
            updateConnectionStatus('연결 해제됨', 'gray');
            document.getElementById('manualStatus').style.display = 'none';
            document.getElementById('currentTokenId').textContent = '-';
            addLogMessage('수동 WebSocket 연결을 해제했습니다.', 'info');
        }
    }

    function disconnectAllAuto() {
        Object.keys(autoConnections).forEach(userId => {
            const connection = autoConnections[userId];
            if (connection && connection.websocket) {
                connection.websocket.close();
                delete autoConnections[userId];
            }
        });

        document.getElementById('autoConnectionGrid').innerHTML = '';
        retryAttempts = {};
        addLogMessage('모든 자동 연결을 해제했습니다.', 'info');
        updateStats();
    }

    function retryFailedConnections() {
        const failedConnections = Object.keys(retryAttempts).filter(userId => retryAttempts[userId] > 0);

        if (failedConnections.length === 0) {
            addLogMessage('재시도할 실패한 연결이 없습니다.', 'info');
            return;
        }

        addLogMessage(`${failedConnections.length}개의 실패한 연결을 재시도합니다.`, 'info');

        failedConnections.forEach((userId, index) => {
            setTimeout(() => {
                retryAttempts[userId] = 0; // 재시도 카운트 리셋
                createAutoConnectionWithRetry(parseInt(userId));
            }, index * 1000);
        });
    }

    function updateConnectionStatus(status, color) {
        const statusElement = document.getElementById('connectionStatus');
        statusElement.textContent = status;
        statusElement.style.color = color;
    }

    function updateStats() {
        const cards = document.querySelectorAll('.connection-card');
        const total = cards.length;
        const connected = document.querySelectorAll('.connection-card.connected, .connection-card.waiting, .connection-card.active').length;
        const failed = document.querySelectorAll('.connection-card.error, .connection-card.expired').length;
        const retrying = Object.values(retryAttempts).filter(count => count > 0 && count < 3).length;

        document.getElementById('totalConnections').textContent = total;
        document.getElementById('connectedCount').textContent = connected;
        document.getElementById('failedCount').textContent = failed;
        document.getElementById('retryingCount').textContent = retrying;
    }

    function addLogMessage(message, type) {
        const logContent = document.getElementById('logContent');
        const timestamp = new Date().toLocaleTimeString();
        const colorMap = {
            'success': '#28a745',
            'info': '#17a2b8',
            'warning': '#ffc107',
            'error': '#dc3545'
        };

        const logEntry = document.createElement('div');
        logEntry.style.color = colorMap[type] || '#ffffff';
        logEntry.style.marginBottom = '5px';
        logEntry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;

        logContent.appendChild(logEntry);
        logContent.scrollTop = logContent.scrollHeight;

        // 로그 개수 제한
        if (logContent.children.length > 100) {
            logContent.removeChild(logContent.firstChild);
        }
    }

    // 페이지 종료 시 연결 정리
    window.addEventListener('beforeunload', function() {
        Object.values(autoConnections).forEach(connection => {
            if (connection && connection.websocket) connection.websocket.close();
        });
        if (manualWebsocket) {
            manualWebsocket.close();
        }
    });
</script>
</body>
</html>